从父进程派生出子进程，子进程完全拷贝父进程的stack，data，heap segment。
>两者并不共享地址空间，所以的变量是独立的，一方修改，另一方不会变化。

### 函数原型
```c
#include <unistd.h>

pid_t fork(void);
```
### 特点
一次调用，两次返回

fork返回值:

- **0** - 如果它返回0，那么当前是子进程。可以通过调用`getppid()`来获取父进程的PID。当然，可以通过调用`getpid()`来获得自己的PID

- **-1** - 如果返回-1，则表示出了问题，并且没有创建子进程。可使用`perror()`查看发生了什么。可能已经进程表已满无法创建新进程

- **其他** - fork()返回的任何其他值都意味着当前pid是父进程，而返回的值是子类的PID。这是获得子进程PID的唯一方法，因为没有`getcpid()`调用(显然是由于父进程和子进程之间的一对多关系)。