### 一文了解Linux中进程间通信编程


### 1.文章简介

一个系统往往运行着很多个进程,如果进程都是孤立的,那到简单了。但多个进程往往是需要协助完成某些任务的。怎么让不同进程间建立起沟通的桥梁呢?Linux 通过System V实现的IPC进程间机制来达到这一目的。本文就是介绍System V的所有进程间通信的方法。这不是讲函数原型的!!

### 2.初探fork

fork是Linux中创建新进程的函数。

#### 2.1fork是危险而又迷人的峡谷

`fork()` 可以让工程师获得创造新生命的权力。权力有时被认为是通往毁灭的车票。因此，当你在你的系统上摆弄`fork()`的时候，你应该小心。`fork()`就是一把锋利的双刃剑,刀刃向敌人可所向披靡,而刀刃亦可轻易割伤自己。

`fork()`是Unix启动新进程的方式。基本上，它的工作原理是这样的:父进程(已经存在的那个)`fork()`一个子进程(新的那个)。子进程获得父进程数据的副本。瞧!您有两个过程，但只有一个函数就完成了!

，在`fork()`进程时，必须处理各种各样的陷阱，当你没有处理然后你把该子进程注册到进程列表中时，你的操作系统管理进程们将会生气，他们必须在机器上按下重置按钮。


首先,得了解一些Unix下进程的行为。当一个进程死亡时，有时它并没有真正完全消失。有的进程死后就不再运行，但有的死后的进程其实是需要父进程来处理它释放它的pcb和资源,此时这类子进程被叫做僵尸进程。因此当父进程 `fork()` 函数指向子进程后，它必须使用 `wait()` (或 `waitpid()` )函数让子进程退出。正是这种等待的行为让这个进程的所有残余(子进程)消失了这个进程才能叫正常结束。才不会有僵尸进程。

上面的规则有一种情况例外:父进程可以忽略SIGCHLD信号(在一些较老的系统上是SIGCLD)，这样它就不必执行 `wait()` 。在支持该操作的系统下可以这么做:

注: `wait()`可以指代为进程回收。

```c
main()
{
    signal(SIGCHLD, SIG_IGN);  /* 没有必要必须使用wait()! */
    .
    .
    fork();fork();fork();  /* fork就完事了 */
}
```

现在，当一个子进程死亡并且没有执行进程回收函数 `wait()` 时(子进程是僵尸进程)，它通常会在ps列表中显示为**defunct**。它将一直保持这种状态，直到父进程`wait()`调用它，或者像下面提到的那样处理它。

另一个规则是:当父进程在等待子进程之前死亡(假设它没有忽略SIGCHLD)，子进程会被重新分配给init进程(PID 1)。如果子进程仍然活得很好并且在控制之下，这不是一个问题。然而，如果子进程还活着，就有会有麻烦了。原父进程不能再`wait()`了，因为它已经死了,此时子进程变为孤儿进程,孤儿进程是交由init进程管理的。那么init是如何`wait()`处理僵尸进程的呢?

在某些系统上，init会周期性地销毁它拥有的所有已死进程。在另外一些系统上，它直接拒绝成为任何失效进程的父进程，而是立即销毁它们。如果你来设计一个init进程，那么可以很容易地编写一个循环，用init拥有的已死进程列表然后不断的`wait()`已死进程直到已死进程列表为空。

所以使用fork得注意两点:

1. 确保父进程忽略SIGHCLD.
2. 为它 `fork()` 的所有子进程执行`wait()` 。

当然不必总是这样做(比如您正在启动一个守护进程或其他什么)，但总之如果要使用`fork()`，那么在编写代码时一定要小心。

总结:除非父进程忽略了SIGCHLD，否则子进程有可能将在父进程`wait()`之前失效。而且，如果父进程没有等待(再次假设父进程没有忽略SIGCHLD)就夭折了，则其子进程(活着的或已死的)将成为init进程的子进程，而init进程会处理他们但是会有很大的开销。

#### 2.2fork使用案例分析

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(void)
{
    pid_t pid; // fork成功,保存子进程的id
    int rv;

    switch(pid = fork()) {
    case -1:
        perror("fork");  /* fork失败了 */
        exit(1);         /* 父进程直接退出 */

    case 0: // 返回0则说明是子进程
        printf(" CHILD: This is the child process!\n");
        printf(" CHILD: My PID is %d\n", getpid()); // 获得当前进程pid
        printf(" CHILD: My parent's PID is %d\n", getppid()); // 获取父进程pid
        printf(" CHILD: Enter my exit status (make it small): ");
        scanf(" %d", &rv); // rv作为子进程被wait()回收时的返回值
        printf(" CHILD: I'm outta here!\n");
        exit(rv);

    default: // 非0则为父进程
        printf("PARENT: This is the parent process!\n");
        printf("PARENT: My PID is %d\n", getpid());
        printf("PARENT: My child's PID is %d\n", pid);
        printf("PARENT: I'm now waiting for my child to exit()...\n");
        wait(&rv); // 等待子进程回收
        printf("PARENT: My child's exit status is: %d\n", WEXITSTATUS(rv));
        printf("PARENT: I'm outta here!\n");
    }

    return 0;
}
```

pid_t是进程类型。在Unix下，这是一个short的(Linux下是int)。因此调用fork()并将返回值保存在pid变量中。fork()很简单，因为它只能返回三个东西:

- **0** - 如果它返回0，那么当前是子进程。可以通过调用`getppid()`来获取父进程的PID。当然，可以通过调用`getpid()`来获得自己的PID

- **-1** - 如果返回-1，则表示出了问题，并且没有创建子进程。可使用`perror()`查看发生了什么。可能已经进程表已满无法创建新进程

- **其他** - fork()返回的任何其他值都意味着当前pid是父进程，而返回的值是子类的PID。这是获得子进程PID的唯一方法，因为没有`getcpid()`调用(显然是由于父进程和子进程之间的一对多关系)。

当子进程最终调用exit()时，传递的返回值将在其父进程`wait()` 时到达。正如从 `wait()` 调用中所看到的，当我们打印返回值时，会出现一些奇怪的情况。这个 `WEXITSTATUS()` 是什么东西呢?这是一个宏，它从`wait()` 返回的值中提取子进程的实际返回值。 具体参照[wait](../docs/wait.md)

这里还有一个疑惑:“wait()如何知道要等待哪个进程?”既然父母可以有多个孩子，那么`wait()`真正等待的是哪个呢?”答案很简单，它会等待最先退出的那一个。如果要等待特定的子进程，可以使用子进程的PID作为参数调用`waitpid()`来指定要等待哪个子进程。

从上面的例子中需要注意的另一件有趣的事情是，父类和子类都使用rv变量。这是否意味着它是在进程之间共享的?不!如果是的话，就不需要了解这些IPC的东西了。每个进程都有自己的所有变量副本。

**进程间的内存不能共享!**

关于上述程序的最后一点注意事项:我使用了switch语句来处理fork()，这并不是很典型。通常你会在那里看到一个if语句;有时它像这样简洁:

```c
if (!fork()) 
{
    printf("I'm the child!\n");
    exit(0);
} 
else 
{
    printf("I'm the parent!\n");
    wait(NULL);
}
```

如果你不关心子对象的返回值是什么，如何使用wait()呢? 你只需要用NULL作为参数调用它。

#### 2.3fork总结

fork能力强大能够极大的利用cpu(尤其是多核)。但于此同时要注意回收它的资源。

下面有几个问题：

子进程创建成功之后,代码执行位置? 父进程到了哪里,子进程就从那里开始。
父子谁先执行? 编程届都是不孝子(笑),C++中子能继承父的方法,父无法调用子。 而父子进程,父子都抢CPU(白富美)谁抢到谁执行。
如何区分父子进程? 通过返回值
父子的数据永远一样吗? fork完成之后一样。读时共享,写时复制。(有血缘关系)

进程回收相关:
1. 孤儿进程
    * 父创建子进程,父进程死亡,子进程还活着。
    * 孤儿进程会被init进程领养,init进程变为其父进程
    * 为了释放子进程占用的资源。为什么init必须成为其父进程呢? 进程结束之后,能够释放用户区空间。释放不了pcb,必须用父进程释放。

2. 僵尸进程
    * 子进程死亡,父进程存活。父进程不去释放子进程的pcb,子进程变为了僵尸进程。
    * 是一个已经死亡的进程
    * 解决方案,直接杀死父进程即可。

